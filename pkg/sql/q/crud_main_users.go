// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package q

import (
	"fmt"
	"zombiezen.com/go/sqlite"

	"time"
)

type UserModel struct {
	CreatedAt *time.Time `json:"created_at"`
	Email     string     `json:"email"`
	Id        int64      `json:"id"`
	Name      string     `json:"name"`
}

type CreateUserStmt struct {
	stmt *sqlite.Stmt
}

func CreateUser(tx *sqlite.Conn) *CreateUserStmt {
	stmt := tx.Prep(`
INSERT INTO users (
        created_at,
        email,
        id,
        name
) VALUES (
        ?,
        ?,
        ?,
        ?
)
    `)
	return &CreateUserStmt{stmt: stmt}
}

func (ps *CreateUserStmt) Run(m *UserModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	if m.CreatedAt == nil {
		ps.stmt.BindNull(1)
	} else {
		ps.stmt.BindFloat(1, TimeToJulianDay(*m.CreatedAt))
	}
	ps.stmt.BindText(2, m.Email)

	ps.stmt.BindInt64(3, m.Id)

	ps.stmt.BindText(4, m.Name)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to insert users: %w", err)
	}

	return nil
}

func OnceCreateUser(tx *sqlite.Conn, m *UserModel) error {
	ps := CreateUser(tx)
	return ps.Run(m)
}

type ReadAllUsersStmt struct {
	stmt *sqlite.Stmt
}

func ReadAllUsers(tx *sqlite.Conn) *ReadAllUsersStmt {
	stmt := tx.Prep(`
SELECT
        created_at,
        email,
        id,
        name
FROM users
    `)
	return &ReadAllUsersStmt{stmt: stmt}
}

func (ps *ReadAllUsersStmt) Run() ([]*UserModel, error) {
	defer ps.stmt.Reset()

	var models []*UserModel
	for {
		hasRow, err := ps.stmt.Step()
		if err != nil {
			return nil, fmt.Errorf("failed to read users: %w", err)
		} else if !hasRow {
			break
		}

		m := &UserModel{}

		if ps.stmt.ColumnIsNull(0) {
			m.CreatedAt = nil
		} else {
			tmp := JulianDayToTime(ps.stmt.ColumnFloat(0))
			m.CreatedAt = &tmp
		}
		m.Email = ps.stmt.ColumnText(1)

		m.Id = ps.stmt.ColumnInt64(2)

		m.Name = ps.stmt.ColumnText(3)

		models = append(models, m)
	}

	return models, nil
}

func OnceReadAllUsers(tx *sqlite.Conn) ([]*UserModel, error) {
	ps := ReadAllUsers(tx)
	return ps.Run()
}

type ReadByIDUserStmt struct {
	stmt *sqlite.Stmt
}

func ReadByIDUser(tx *sqlite.Conn) *ReadByIDUserStmt {
	stmt := tx.Prep(`
SELECT
        created_at,
        email,
        id,
        name
FROM users
WHERE id = ?
    `)
	return &ReadByIDUserStmt{stmt: stmt}
}

func (ps *ReadByIDUserStmt) Run(id int64) (*UserModel, error) {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if hasRow, err := ps.stmt.Step(); err != nil {
		return nil, fmt.Errorf("failed to read users: %w", err)
	} else if !hasRow {
		return nil, nil
	}

	m := &UserModel{}

	if ps.stmt.ColumnIsNull(0) {
		m.CreatedAt = nil
	} else {
		tmp := JulianDayToTime(ps.stmt.ColumnFloat(0))
		m.CreatedAt = &tmp
	}
	m.Email = ps.stmt.ColumnText(1)

	m.Id = ps.stmt.ColumnInt64(2)

	m.Name = ps.stmt.ColumnText(3)

	return m, nil
}

func OnceReadByIDUser(tx *sqlite.Conn, id int64) (*UserModel, error) {
	ps := ReadByIDUser(tx)
	return ps.Run(id)
}

func CountUsers(tx *sqlite.Conn) (int64, error) {
	stmt := tx.Prep(`
SELECT COUNT(*)
FROM users
    `)
	defer stmt.Reset()

	if hasRow, err := stmt.Step(); err != nil {
		return 0, fmt.Errorf("failed to count users: %w", err)
	} else if !hasRow {
		return 0, nil
	}

	return stmt.ColumnInt64(0), nil
}

func OnceCountUsers(tx *sqlite.Conn) (int64, error) {
	return CountUsers(tx)
}

type UpdateUserStmt struct {
	stmt *sqlite.Stmt
}

func UpdateUser(tx *sqlite.Conn) *UpdateUserStmt {
	stmt := tx.Prep(`
UPDATE users
SET
        email = ?2,
        id = ?3,
        name = ?4
WHERE id = ?1
    `)
	return &UpdateUserStmt{stmt: stmt}
}

func (ps *UpdateUserStmt) Run(m *UserModel) error {
	defer ps.stmt.Reset()

	// Bind parameters
	if m.CreatedAt == nil {
		ps.stmt.BindNull(1)
	} else {
		ps.stmt.BindFloat(1, TimeToJulianDay(*m.CreatedAt))
	}
	ps.stmt.BindText(2, m.Email)

	ps.stmt.BindInt64(3, m.Id)

	ps.stmt.BindText(4, m.Name)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to update users: %w", err)
	}

	return nil
}

func OnceUpdateUser(tx *sqlite.Conn, m *UserModel) error {
	ps := UpdateUser(tx)
	return ps.Run(m)
}

type DeleteUserStmt struct {
	stmt *sqlite.Stmt
}

func DeleteUser(tx *sqlite.Conn) *DeleteUserStmt {
	stmt := tx.Prep(`
DELETE FROM users
WHERE id = ?
    `)
	return &DeleteUserStmt{stmt: stmt}
}

func (ps *DeleteUserStmt) Run(id int64) error {
	defer ps.stmt.Reset()

	ps.stmt.BindInt64(1, id)

	if _, err := ps.stmt.Step(); err != nil {
		return fmt.Errorf("failed to delete users: %w", err)
	}

	return nil
}

func OnceDeleteUser(tx *sqlite.Conn, id int64) error {
	ps := DeleteUser(tx)
	return ps.Run(id)
}
