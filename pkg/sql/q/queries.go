// Code generated by "sqlc-gen-zz". DO NOT EDIT.

package q

import (
	"database/sql"
	"encoding/json"
	"time"

	"zombiezen.com/go/sqlite"

	"github.com/nzoschke/codon/pkg/sql/models"
)

type ContactCreateIn struct {
	Email string      `json:"email"`
	Meta  models.Meta `json:"meta"`
	Name  string      `json:"name"`
	Phone string      `json:"phone"`
}

type ContactCreateOut struct {
	CreatedAt time.Time   `json:"created_at"`
	Email     string      `json:"email"`
	Id        int64       `json:"id"`
	Meta      models.Meta `json:"meta"`
	Name      string      `json:"name"`
	Phone     string      `json:"phone"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func ContactCreate(tx *sqlite.Conn, in ContactCreateIn) (*ContactCreateOut, error) {
	stmt := tx.Prep(`INSERT INTO
  contacts (email, meta, name, phone)
VALUES
  (?, ?, ?, ?)
RETURNING
  created_at, email, id, meta, name, phone, updated_at`)
	defer stmt.Reset()

	stmt.BindText(1, in.Email)
	stmt.BindBytes(2, jsonMarshal(in.Meta))
	stmt.BindText(3, in.Name)
	stmt.BindText(4, in.Phone)

	ok, err := stmt.Step()
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, sql.ErrNoRows
	}

	out := ContactCreateOut{}
	out.CreatedAt = timeParse(stmt.ColumnText(0))
	out.Email = stmt.ColumnText(1)
	out.Id = stmt.ColumnInt64(2)
	out.Meta = jsonUnmarshalModelsMeta([]byte(stmt.ColumnText(3)))
	out.Name = stmt.ColumnText(4)
	out.Phone = stmt.ColumnText(5)
	out.UpdatedAt = timeParse(stmt.ColumnText(6))

	return &out, nil

}

type ContactReadOut struct {
	CreatedAt time.Time   `json:"created_at"`
	Email     string      `json:"email"`
	Id        int64       `json:"id"`
	Meta      models.Meta `json:"meta"`
	Name      string      `json:"name"`
	Phone     string      `json:"phone"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func ContactRead(tx *sqlite.Conn, id int64) (*ContactReadOut, error) {
	stmt := tx.Prep(`SELECT
  created_at, email, id, meta, name, phone, updated_at
FROM
  contacts
WHERE
  id = ?
LIMIT
  1`)
	defer stmt.Reset()

	stmt.BindInt64(1, id)

	ok, err := stmt.Step()
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, sql.ErrNoRows
	}

	out := ContactReadOut{}
	out.CreatedAt = timeParse(stmt.ColumnText(0))
	out.Email = stmt.ColumnText(1)
	out.Id = stmt.ColumnInt64(2)
	out.Meta = jsonUnmarshalModelsMeta([]byte(stmt.ColumnText(3)))
	out.Name = stmt.ColumnText(4)
	out.Phone = stmt.ColumnText(5)
	out.UpdatedAt = timeParse(stmt.ColumnText(6))

	return &out, nil

}

type ContactUpdateIn struct {
	Email string      `json:"email"`
	Meta  models.Meta `json:"meta"`
	Name  string      `json:"name"`
	Phone string      `json:"phone"`
	Id    int64       `json:"id"`
}

func ContactUpdate(tx *sqlite.Conn, in ContactUpdateIn) error {
	stmt := tx.Prep(`UPDATE
  contacts
SET
  email = ?,
  meta = ?,
  name = ?,
  phone = ?,
  updated_at = CURRENT_TIMESTAMP
WHERE
  id = ?`)
	defer stmt.Reset()

	stmt.BindText(1, in.Email)
	stmt.BindBytes(2, jsonMarshal(in.Meta))
	stmt.BindText(3, in.Name)
	stmt.BindText(4, in.Phone)
	stmt.BindInt64(5, in.Id)

	_, err := stmt.Step()
	if err != nil {
		return err
	}

	return nil
}

func ContactDelete(tx *sqlite.Conn, id int64) error {
	stmt := tx.Prep(`DELETE FROM
  contacts
WHERE
  id = ?`)
	defer stmt.Reset()

	stmt.BindInt64(1, id)

	_, err := stmt.Step()
	if err != nil {
		return err
	}

	return nil
}

type ContactListOut []ContactListRow

type ContactListRow struct {
	CreatedAt time.Time   `json:"created_at"`
	Email     string      `json:"email"`
	Id        int64       `json:"id"`
	Meta      models.Meta `json:"meta"`
	Name      string      `json:"name"`
	Phone     string      `json:"phone"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func ContactList(tx *sqlite.Conn, limit int64) (ContactListOut, error) {
	stmt := tx.Prep(`SELECT
  created_at, email, id, meta, name, phone, updated_at
FROM
  contacts
ORDER BY
  created_at DESC
LIMIT
  ?`)
	defer stmt.Reset()

	stmt.BindInt64(1, limit)

	out := ContactListOut{}
	for {
		ok, err := stmt.Step()
		if err != nil {
			return nil, err
		}
		if !ok {
			break
		}

		row := ContactListRow{}
		row.CreatedAt = timeParse(stmt.ColumnText(0))
		row.Email = stmt.ColumnText(1)
		row.Id = stmt.ColumnInt64(2)
		row.Meta = jsonUnmarshalModelsMeta([]byte(stmt.ColumnText(3)))
		row.Name = stmt.ColumnText(4)
		row.Phone = stmt.ColumnText(5)
		row.UpdatedAt = timeParse(stmt.ColumnText(6))

		out = append(out, row)
	}

	return out, nil
}

type ContactAgeOut struct {
	Age int64 `json:"age"`
}

func ContactAge(tx *sqlite.Conn, id int64) (int64, error) {
	stmt := tx.Prep(`SELECT
  CAST(meta ->> '$.age' AS INTEGER) AS age
FROM
  contacts
WHERE
  id = ?
LIMIT
  1`)
	defer stmt.Reset()

	stmt.BindInt64(1, id)

	ok, err := stmt.Step()
	if err != nil {
		return 0, err
	}
	if !ok {
		return 0, sql.ErrNoRows
	}

	return stmt.ColumnInt64(0), nil

}

func jsonMarshal(v any) []byte {
	bs, _ := json.Marshal(v)
	return bs
}

func jsonUnmarshalModelsMeta(bs []byte) models.Meta {
	var v models.Meta
	json.Unmarshal(bs, &v)
	return v
}

func timeParse(s string) time.Time {
	t, _ := time.Parse("2006-01-02 15:04:05", s)
	return t
}
